<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Hello World!</title>
    <link rel="stylesheet" href="bulma.min.css">
    <style type="text/css">
        .axis path, .axis line {
            fill: none;
            stroke: black;
            shape-rendering: crispEdges;  /* Round any decimal pixels so it'll render nicely */
        }

        .tick text{
            font-size: 12px;
        }

        .tick line{
            opacity: 0.2;
        }
    </style>
</head>
<body>
<section class="section">
<div class="container">
<button class="button is-primary" id="save-to-file-btn" onclick="saveToFile()">Сохранить в файл</button>
<button class="button is-primary" id="load-from-file-btn" onclick="loadFromFile()">Загрузить из файла</button>
<button class="button is-warning" id="clear-btn" onclick="clearGraph()">Очистить график</button>
</div>
<div class="container" id="d3"></div> <!-- container for our svg graph -->
</section>
<script>
    const d3 = require("d3");  //library for graph
    const fs = require('fs');  //API for filesystem operations from node.js

    const svgWidth = window.innerWidth*0.7,
          svgHeight = window.innerHeight*0.7,
          svgMargin = { top: 40, right: 20, bottom: 20, left: 40 },
          xLeftBoundary = -100,
          xRightBoundary = 100,
          yBottomBoundary = -100,
          yTopBoundary = 100,
          pointRadius = 3;

    const svg = d3.select("#d3")    //selecting our container from html
                  .append("svg")    //this svg will contain our graph
                  .attr("width", svgWidth)  //setting width and height attributes of svg
                  .attr("height", svgHeight)
                  .on("click", clickOnSvgHandler)  //setting click handler
                  .on("contextmenu", rightClickOnSvgHandler);

    let pointsArray = [];  //our points, like [ {x:1.5, y:3}, {x:-2, y:0} ]
    let offsetPointsArray = [];
    let selectedPoint = null;
    let selectedOffsetPoint = null;

    const xScale = d3.scaleLinear()  //this thing transform points coordinates to svg coordinates
        .domain([ xLeftBoundary, xRightBoundary ])    //boundaries of points' x coordinates
        .range([svgMargin.left, svgWidth - svgMargin.right]);   //boundaries of svg's x coordinates

    const yScale = d3.scaleLinear()
        .domain([ yBottomBoundary, yTopBoundary ])
        .range([svgHeight - svgMargin.bottom, svgMargin.top]); //inverted to invert screen y axis

    initAxes();

    function initAxes(){
        // Add an X and an Y Axis
        const xAxis = d3.axisBottom(xScale)
            .tickSizeInner(-(svgHeight-svgMargin.top-svgMargin.bottom)) //grid lines
            .tickSizeOuter(0)
            .tickPadding(10);

        const yAxis = d3.axisLeft(yScale)
            .tickSizeInner(-(svgWidth-svgMargin.left-svgMargin.right))  //grid lines
            .tickSizeOuter(0)
            .tickPadding(10);

        // Adds X-Axis to svg as a 'g' element (group)
        svg.append("g")
            .attr("class", "axis")  // Give class so we can style it
            .attr("transform", "translate(" + [0, svgHeight - svgMargin.bottom] + ")")  // Translate just moves it down into position (or will be on top)
            .call(xAxis);

        // Adds Y-Axis to svg as a 'g' element (group)
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + [svgMargin.left, 0] + ")")
            .call(yAxis);
    }

    function drawPoints(drawLines){  //if drawLines===true and we have at least 3 points, we draw lines around them
        d3.selectAll("circle").remove(); //delete all old points

        svg.selectAll("circle")
           .data(pointsArray)
           .enter()               // Kind of setting model, https://github.com/d3/d3-selection#selection_enter
           .append("circle")
           .attr("cx", point => xScale(point.x)) // setting coordinates and radius for each point
           .attr("cy", point => yScale(point.y))
           .attr("r", pointRadius)
           .on("mouseover", mouseOverPointHandler) //setting event handlers
           .on("mouseout", mouseOutPointHandler)
           .on("click", clickOnPointHandler)
           .on("contextmenu", rightClickOnPointHandler)
           .exit();

        if(drawLines === true && pointsArray.length >= 3){
            d3.selectAll(".graphline").remove();  //delete all old lines
            for(let i = 0; i < pointsArray.length; i++) {
                const nowPoint = pointsArray[i];
                const nextPoint = (i === pointsArray.length - 1) ? pointsArray[0] : pointsArray[i+1];  //ternary operator
                svg.append("line")          // attach a line
                    .style("stroke", "black")  // colour the line
                    .attr("class", "graphline")
                    .attr("x1", xScale(nowPoint.x))     // x position of the first end of the line
                    .attr("y1", yScale(nowPoint.y))      // y position of the first end of the line
                    .attr("x2", xScale(nextPoint.x))     // x position of the second end of the line
                    .attr("y2", yScale(nextPoint.y));    // y position of the second end of the line
            }
        }

        for(let i = 0; i < offsetPointsArray.length; i++) {
            const point = pointsArray[i];
            const offsetPoint = offsetPointsArray[i];
            const nextOffsetPoint = (i === offsetPointsArray.length - 1) ? offsetPointsArray[0] : offsetPointsArray[i+1];
            if (point.x != offsetPoint.x ||
                point.y != offsetPoint.y) {

                svg.append("circle")
                   .attr("cx", xScale(offsetPoint.x)) // setting coordinates and radius for each point
                   .attr("cy", yScale(offsetPoint.y))
                   .attr("r", pointRadius)
                   .attr("fill", "blue");

                svg.append("line")
                   .style("stroke", "red")
                   .attr("class", "graphline")
                   .attr("x1", xScale(point.x))
                   .attr("y1", yScale(point.y))
                   .attr("x2", xScale(offsetPoint.x))
                   .attr("y2", yScale(offsetPoint.y));

                if (offsetPointsArray.length > 1) {
                    svg.append("line")
                       .style("stroke", "blue")
                       .attr("class", "graphline")
                       .attr("x1", xScale(nextOffsetPoint.x))
                       .attr("y1", yScale(nextOffsetPoint.y))
                       .attr("x2", xScale(offsetPoint.x))
                       .attr("y2", yScale(offsetPoint.y));
                }
            }
        }

    }

    // On click, we want to add data to the array and chart
    function clickOnSvgHandler(){
        const coords = d3.mouse(this);

        // Normally we go from data to pixels, but here we're doing pixels to data
        const newPoint= {
            x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
            y: Math.round( yScale.invert(coords[1]))
        };

        const offsetPoint = Object.create(newPoint);

        pointsArray.push(newPoint);   // Push data to our array
        offsetPointsArray.push(offsetPoint);

        drawPoints();

        if(pointsArray.length >= 2) {  // draw a line between the new point and the last point
            const prevPoint = pointsArray[pointsArray.length - 2];
            svg.append("line")          // attach a line
                .style("stroke", "black")  // colour the line
                .attr("class", "graphline")
                .attr("x1", xScale(prevPoint.x))     // x position of the first end of the line
                .attr("y1", yScale(prevPoint.y))      // y position of the first end of the line
                .attr("x2", xScale(newPoint.x))     // x position of the second end of the line
                .attr("y2", yScale(newPoint.y));    // y position of the second end of the line
        }
    }

    function rightClickOnSvgHandler() {
        d3.event.preventDefault();
        d3.event.stopPropagation();
        const coords = d3.mouse(this);
        selectedOffsetPoint.x = Math.round( xScale.invert(coords[0]));
        selectedOffsetPoint.y = Math.round( yScale.invert(coords[1]));
        drawPoints(true);
    }

    function clickOnPointHandler(point) { //creating a line between the last point and the first point
        d3.event.stopPropagation();  //otherwise svg will receive click and create a new point
        if(pointsArray.length >= 3) {
            const lastPoint = pointsArray[pointsArray.length - 1];
            const firstPoint = pointsArray[0];
            svg.append("line")          // attach a line
                .style("stroke", "black")  // colour the line
                .attr("class", "graphline")
                .attr("x1", xScale(lastPoint.x))     // x position of the first end of the line
                .attr("y1", yScale(lastPoint.y))      // y position of the first end of the line
                .attr("x2", xScale(firstPoint.x))     // x position of the second end of the line
                .attr("y2", yScale(firstPoint.y));    // y position of the second end of the line
        }
    }

    function rightClickOnPointHandler(point, index) {
        d3.event.preventDefault();
        d3.event.stopPropagation();

        d3.select(this)
          .attr("fill", "red")
          .attr("r", pointRadius * 3);

        selectedPoint = point;
        selectedOffsetPoint = offsetPointsArray[pointsArray.indexOf(point)];
    }

    function getPointStringId(point) {
        return "t" + String(point.x).replace(".","-") + "-" + String(point.y).replace(".","-");
    }

    function mouseOverPointHandler(point) {  // Add interactivity

        // Use D3 to select element, change color and size
        d3.select(this)
            .attr("fill", "orange")
            .attr("r", pointRadius * 2);

        // Specify where to put label of text
        svg.append("text")
            .attr("id", getPointStringId(point))  // Create an id for text so we can select it later for removing on mouseout
            .attr("x", xScale(point.x) - 30 )
            .attr("y", yScale(point.y) - 15 )
            .text( point.x + ", " + point.y );  // Value of the text
    }

    function mouseOutPointHandler(point) {
        // Use D3 to select element, change color back to normal
        d3.select(this)
            .attr("fill", "black")
            .attr("r", pointRadius);

        // Select text by id and then remove
        d3.select("#"+getPointStringId(point)).remove();  // Remove text location
    }

    function saveToFile() {
        let outputString = "";
        for(let i=0; i<pointsArray.length; i++){
            const point = pointsArray[i];
            outputString += point.x + " " + point.y;
            if(i !== pointsArray.length - 1)
                outputString += "\n";
        }
        fs.writeFile("src_data.txt", outputString, function(err) {
            if(err)
                console.log(err);
            else
                console.log("The file was saved!");
        });


        // Calc and save offsets
        outputString = "";
        for(let i = 0; i < offsetPointsArray.length; i++) {
            const point = pointsArray[i];
            const offsetPoint = offsetPointsArray[i];
            outputString += i + " " + (offsetPoint.x - point.x) + " " + (offsetPoint.y - point.y);
            if(i !== offsetPointsArray.length - 1)
                outputString += "\n";
        }

        fs.writeFile("src_constraints.txt", outputString, function(err) {
            if(err)
                console.log(err);
            else
                console.log("The offset file was saved!");
        });
    }

    function loadFromFile() {
        contents = fs.readFileSync('src_data.txt', 'utf8');
        lines = contents.split("\n");
        let newPointsArray = [];
        for(let i=0; i<lines.length; i++){
            const line = lines[i];
            const numbersAsString = line.split(" ");
            const x = parseFloat(numbersAsString[0]);
            const y = parseFloat(numbersAsString[1]);
            if(isFinite(x) && isFinite(y)) {
                newPointsArray.push({x: x, y: y});
            }
        }

        pointsArray = newPointsArray;

        // Load offsets into offset points array
        contents = fs.readFileSync('src_constraints.txt', 'utf8');
        lines = contents.split("\n");
        offsetPointsArray = [];
        for(let i = 0; i < lines.length; i++) {
            const point = pointsArray[i];
            const line = lines[i];
            const numbersAsString = line.split(" ");
            const x = point.x + parseFloat(numbersAsString[1]);
            const y = point.y + parseFloat(numbersAsString[2]);
            if (isFinite(x) && isFinite(y)) {
                offsetPointsArray.push({x: x, y: y});
            }
        }

        drawPoints(true); //draw new points and lines
    }

    function clearGraph() {
        pointsArray = [];
        d3.selectAll("circle").remove();
        d3.selectAll(".graphline").remove();
    }
</script>
</body>
</html>
