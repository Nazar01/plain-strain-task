<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Plain strain task</title>
    <link rel="stylesheet" href="bulma.min.css">
    <style type="text/css">
        .axis path, .axis line {
            fill: none;
            stroke: black;
            shape-rendering: crispEdges;  /* Round any decimal pixels so it'll render nicely */
        }

        .tick text{
            font-size: 12px;
        }

        .tick line{
            opacity: 0.2;
        }
    </style>
</head>
<body>
<section class="section">
<div class="container">
<button class="button is-primary" id="save-to-file-btn" onclick="saveToFile()">Сохранить в файл</button>
<button class="button is-primary" id="load-from-file-btn" onclick="loadFromFile()">Загрузить из файла</button>
<button class="button is-primary" id="triangle-mode-btn" onclick="changeMode()">Триангуляция</button>
<button class="button is-warning" id="clear-btn" onclick="clearGraph()">Очистить график</button>
</div>
<div class="container" id="d3"></div> <!-- container for our svg graph -->
</section>
<script>
    const d3 = require("d3");  //library for graph
    const fs = require('fs');  //API for filesystem operations from node.js

    const svgWidth = window.innerWidth*0.7,
          svgHeight = window.innerHeight*0.7,
          svgMargin = { top: 40, right: 20, bottom: 20, left: 40 },
          xLeftBoundary = -100,
          xRightBoundary = 100,
          yBottomBoundary = -100,
          yTopBoundary = 100,
          pointRadius = 3;

    const svg = d3.select("#d3")    //selecting our container from html
                  .append("svg")    //this svg will contain our graph
                  .attr("width", svgWidth)  //setting width and height attributes of svg
                  .attr("height", svgHeight)
                  .on("click", clickOnSvgHandler)  //setting click handler
                  .on("contextmenu", rightClickOnSvgHandler);

    let pointsArray = [];  //our points, like [ {x:1.5, y:3}, {x:-2, y:0} ]
    let offsetPointsArray = [];
    let selectedPoint = null;
    let prevSelectedPoint = null;
    let selectedCorrespondingOffsetPoint = null;
    let trianglePoints = [];
    let triangleContactPointNumbers = [];
    let isTriangleMode = false;

    const xScale = d3.scaleLinear()  //this thing transform points coordinates to svg coordinates
        .domain([ xLeftBoundary, xRightBoundary ])    //boundaries of points' x coordinates
        .range([svgMargin.left, svgWidth - svgMargin.right]);   //boundaries of svg's x coordinates

    const yScale = d3.scaleLinear()
        .domain([ yBottomBoundary, yTopBoundary ])
        .range([svgHeight - svgMargin.bottom, svgMargin.top]); //inverted to invert screen y axis

    initAxes();

    function initAxes(){
        // Add an X and an Y Axis
        const xAxis = d3.axisBottom(xScale)
            .tickSizeInner(-(svgHeight-svgMargin.top-svgMargin.bottom)) //grid lines
            .tickSizeOuter(0)
            .tickPadding(10);

        const yAxis = d3.axisLeft(yScale)
            .tickSizeInner(-(svgWidth-svgMargin.left-svgMargin.right))  //grid lines
            .tickSizeOuter(0)
            .tickPadding(10);

        // Adds X-Axis to svg as a 'g' element (group)
        svg.append("g")
            .attr("class", "axis")  // Give class so we can style it
            .attr("transform", "translate(" + [0, svgHeight - svgMargin.bottom] + ")")  // Translate just moves it down into position (or will be on top)
            .call(xAxis);

        // Adds Y-Axis to svg as a 'g' element (group)
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + [svgMargin.left, 0] + ")")
            .call(yAxis);
    }

    function drawPoints(drawLines){  //if drawLines===true and we have at least 3 points, we draw lines around them
        d3.selectAll("circle").remove(); //delete all old points

        svg.selectAll("circle.point")
           .data(pointsArray)
           .enter()               // Kind of setting model, https://github.com/d3/d3-selection#selection_enter
           .append("circle")
           .attr("class", "point")
           .attr("cx", point => xScale(point.x)) // setting coordinates and radius for each point
           .attr("cy", point => yScale(point.y))
           .attr("r", pointRadius)
           .on("mouseover", mouseOverAnyPointHandler) //setting event handlers
           .on("mouseout", mouseOutAnyPointHandler)
           .on("click", clickOnPointHandler)
           .on("contextmenu", rightClickOnPointHandler);

        if(drawLines === true && pointsArray.length >= 3){
            d3.selectAll(".graphline").remove();  //delete all old lines
            for(let i = 0; i < pointsArray.length; i++) {
                const nowPoint = pointsArray[i];
                const nextPoint = (i === pointsArray.length - 1) ? pointsArray[0] : pointsArray[i+1];  //ternary operator
                svg.append("line")          // attach a line
                    .style("stroke", "black")  // colour the line
                    .attr("class", "graphline")
                    .attr("x1", xScale(nowPoint.x))     // x position of the first end of the line
                    .attr("y1", yScale(nowPoint.y))      // y position of the first end of the line
                    .attr("x2", xScale(nextPoint.x))     // x position of the second end of the line
                    .attr("y2", yScale(nextPoint.y));    // y position of the second end of the line
            }
        }

        for(let i = 0; i < offsetPointsArray.length; i++) {
            const point = pointsArray[i];
            const offsetPoint = offsetPointsArray[i];
            if(offsetPoint == null)
                continue;

            let nextAnyPoint = (i === offsetPointsArray.length - 1) ? offsetPointsArray[0] : offsetPointsArray[i+1];
            if(nextAnyPoint == null)
                nextAnyPoint = (i === pointsArray.length - 1) ? pointsArray[0] : pointsArray[i+1];

            let prevOffsetPoint = (i === 0) ? offsetPointsArray[offsetPointsArray.length - 1] : offsetPointsArray[i-1];
            let prevPoint = (i === 0) ? pointsArray[offsetPointsArray.length - 1] : pointsArray[i-1];

            if (point.x !== offsetPoint.x || point.y !== offsetPoint.y) {
                svg.selectAll("circle.offsetpoint"+i)
                    .data([offsetPoint])
                    .enter()
                    .append("circle")
                    .attr("class", "offsetpoint"+i)
                    .attr("cx", xScale(offsetPoint.x)) // setting coordinates and radius for each point
                    .attr("cy", yScale(offsetPoint.y))
                    .attr("r", pointRadius)
                    .attr("fill", "blue")
                    .on("mouseover", mouseOverAnyPointHandler) //setting event handlers
                    .on("mouseout", mouseOutAnyPointHandler);

                svg.append("line")
                   .style("stroke", "red")
                   .attr("class", "graphline")
                   .attr("x1", xScale(point.x))
                   .attr("y1", yScale(point.y))
                   .attr("x2", xScale(offsetPoint.x))
                   .attr("y2", yScale(offsetPoint.y));

                if (drawLines === true && pointsArray.length >= 3) {
                    svg.append("line")
                       .style("stroke", "blue")
                       .attr("class", "graphline")
                       .attr("x1", xScale(nextAnyPoint.x))
                       .attr("y1", yScale(nextAnyPoint.y))
                       .attr("x2", xScale(offsetPoint.x))
                       .attr("y2", yScale(offsetPoint.y));
                    if(prevOffsetPoint == null){
                        svg.append("line")
                            .style("stroke", "blue")
                            .attr("class", "graphline")
                            .attr("x1", xScale(prevPoint.x))
                            .attr("y1", yScale(prevPoint.y))
                            .attr("x2", xScale(offsetPoint.x))
                            .attr("y2", yScale(offsetPoint.y));
                    }
                }
            }
        }

        if (isTriangleMode) {
            svg.selectAll("circle")
                .data(trianglePoints)
                .enter()               // Kind of setting model, https://github.com/d3/d3-selection#selection_enter
                .append("circle")
                .attr("cx", point => xScale(point.x)) // setting coordinates and radius for each point
                .attr("cy", point => yScale(point.y))
                .attr("r", pointRadius)
                .attr("fill", "green")
                .on("mouseover", mouseOverAnyPointHandler) //setting event handlers
                .on("mouseout", mouseOutAnyPointHandler)
                .on("click", clickOnPointHandler)
                .on("contextmenu", rightClickOnPointHandler)
                .exit();

            for (let i = 0; i<triangleContactPointNumbers.length; i++) {
                for (let j = 0; j<triangleContactPointNumbers[i].length; j++) {
                    let trianglePoint = trianglePoints[i];
                    let point = pointsArray[triangleContactPointNumbers[i][j]];
                    svg.append("line")
                        .style("stroke", "green")
                        .attr("class", "graphline")
                        .attr("x1", xScale(trianglePoint.x))
                        .attr("y1", yScale(trianglePoint.y))
                        .attr("x2", xScale(point.x))
                        .attr("y2", yScale(point.y));
                }
            }
        }
    }

    // On click, we want to add data to the array and chart
    function clickOnSvgHandler(){
        const coords = d3.mouse(this);

        // Normally we go from data to pixels, but here we're doing pixels to data
        const newPoint= {
            x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
            y: Math.round( yScale.invert(coords[1]))
        };

        const offsetPoint = null; //no constraints by default

        pointsArray.push(newPoint);   // Push data to our array
        offsetPointsArray.push(offsetPoint);

        drawPoints(false);

        if(pointsArray.length >= 2) {  // draw a line between the new point and the last point
            const prevPoint = pointsArray[pointsArray.length - 2];
            svg.append("line")          // attach a line
                .style("stroke", "black")  // colour the line
                .attr("class", "graphline")
                .attr("x1", xScale(prevPoint.x))     // x position of the first end of the line
                .attr("y1", yScale(prevPoint.y))      // y position of the first end of the line
                .attr("x2", xScale(newPoint.x))     // x position of the second end of the line
                .attr("y2", yScale(newPoint.y));    // y position of the second end of the line
        }
    }

    function rightClickOnSvgHandler() {
        d3.event.preventDefault();
        d3.event.stopPropagation();
        const coords = d3.mouse(this);

        if (isTriangleMode) {
            const newPoint= {
                x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                y: Math.round( yScale.invert(coords[1]))
            };
            trianglePoints.push(newPoint);
            triangleContactPointNumbers.push([
                pointsArray.indexOf(prevSelectedPoint),
                pointsArray.indexOf(selectedPoint)
            ])
        } else {
            if(selectedCorrespondingOffsetPoint != null) {
                selectedCorrespondingOffsetPoint.x = Math.round(xScale.invert(coords[0]));
                selectedCorrespondingOffsetPoint.y = Math.round(yScale.invert(coords[1]));
            }
        }
        drawPoints(true);
    }

    function clickOnPointHandler(point) { //creating a line between the last point and the first point
        d3.event.stopPropagation();  //otherwise svg will receive click and create a new point
        if(pointsArray.length >= 3) {
            const lastPoint = pointsArray[pointsArray.length - 1];
            const firstPoint = pointsArray[0];
            svg.append("line")          // attach a line
                .style("stroke", "black")  // colour the line
                .attr("class", "graphline")
                .attr("x1", xScale(lastPoint.x))     // x position of the first end of the line
                .attr("y1", yScale(lastPoint.y))      // y position of the first end of the line
                .attr("x2", xScale(firstPoint.x))     // x position of the second end of the line
                .attr("y2", yScale(firstPoint.y));    // y position of the second end of the line
        }
    }

    function rightClickOnPointHandler(point) {
        d3.event.preventDefault();
        d3.event.stopPropagation();

        d3.select(this)
          .attr("fill", "red")
          .attr("r", pointRadius * 3);

        prevSelectedPoint = selectedPoint;
        selectedPoint = point;
        selectedCorrespondingOffsetPoint = offsetPointsArray[pointsArray.indexOf(point)];
        if(selectedCorrespondingOffsetPoint == null){
            offsetPointsArray[pointsArray.indexOf(point)] = Object.create(point);
            selectedCorrespondingOffsetPoint = offsetPointsArray[pointsArray.indexOf(point)];
        }
    }

    function getPointStringId(point) {
        return "t" + String(point.x).replace(".","-") + "-" + String(point.y).replace(".","-");
    }

    function mouseOverAnyPointHandler(point) {  // Add interactivity
        // Use D3 to select element, change color and size
        d3.select(this)
            .attr("fill", "orange")
            .attr("r", pointRadius * 2);

        // Specify where to put label of text
        svg.append("text")
            .attr("id", getPointStringId(point))  // Create an id for text so we can select it later for removing on mouseout
            .attr("x", xScale(point.x) - 30 )
            .attr("y", yScale(point.y) - 15 )
            .text( point.x + ", " + point.y );  // Value of the text
    }

    function mouseOutAnyPointHandler(point) {
        // Use D3 to select element, change color back to normal
        const color = (pointsArray.indexOf(point)===-1) ? "blue":"black";
        d3.select(this)
            .attr("fill", color)
            .attr("r", pointRadius);

        // Select text by id and then remove
        d3.select("#"+getPointStringId(point)).remove();  // Remove text location
    }

    function saveToFile() {
        let outputString = "";
        for(let i=0; i<pointsArray.length; i++){
            const point = pointsArray[i];
            outputString += point.x + " " + point.y;
            if(i !== pointsArray.length - 1)
                outputString += "\n";
        }
        fs.writeFile("src_data.txt", outputString, function(err) {
            if(err)
                console.log(err);
            else
                console.log("The file was saved!");
        });


        // Calc and save offsets
        outputString = "";
        for(let i = 0; i < offsetPointsArray.length; i++) {
            const offsetPoint = offsetPointsArray[i];
            if(offsetPoint == null)
                continue;
            outputString += i + " " + (offsetPoint.x) + " " + (offsetPoint.y) + "\n";
        }

        if(outputString.length > 0)
            outputString = outputString.slice(0, -1); //deleting last \n

        fs.writeFile("src_constraints.txt", outputString, function(err) {
            if(err)
                console.log(err);
            else
                console.log("The offset file was saved!");
        });
    }

    function loadFromFile() {
        clearGraph();

        let contents = fs.readFileSync('src_data.txt', 'utf8');
        let lines = contents.split("\n");
        pointsArray = [];
        for(let i=0; i<lines.length; i++){
            const line = lines[i];
            const numbersAsString = line.split(" ");
            const x = parseFloat(numbersAsString[0]);
            const y = parseFloat(numbersAsString[1]);
            if(isFinite(x) && isFinite(y)) {
                pointsArray.push({x: x, y: y});
            }
        }

        // Load offsets into offset points array
        contents = fs.readFileSync('src_constraints.txt', 'utf8');
        lines = contents.split("\n");

        offsetPointsArray = [];
        for(let i = 0; i < pointsArray.length; i++)
            offsetPointsArray.push(null);

        for(let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const numbersAsString = line.split(" ");
            const point_i = parseInt(numbersAsString[0]);
            const x = parseFloat(numbersAsString[1]);
            const y = parseFloat(numbersAsString[2]);
            if (isFinite(x) && isFinite(y)) {
                offsetPointsArray[point_i] = {x: x, y: y};
            }
        }

        drawPoints(true); //draw new points and lines
    }

    function changeMode() {
        isTriangleMode = !isTriangleMode;
        document.getElementById("triangle-mode-btn").textContent = isTriangleMode ? "Нач. Условия" : "Триангуляция";
        drawPoints(true)
    }

    function clearGraph() {
        pointsArray = [];
        offsetPointsArray = [];
        selectedPoint = null;
        prevSelectedPoint = null;
        trianglePoints = [];
        triangleContactPointNumbers = [];
        d3.selectAll("circle").remove();
        d3.selectAll(".graphline").remove();
    }
</script>
</body>
</html>
